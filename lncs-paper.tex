% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{url}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{xcolor}

\lstdefinestyle{fancy}{
language=Haskell,
deletekeywords={Int,Bool,String,Functor,Char,True,False,
  Maybe,Nothing,Just,Show,show,Monad,catMaybes,const,id},
morekeywords={family},
basicstyle=\color{cbasic}\rmfamily,
identifierstyle=\color{cid}\rmfamily\itshape,
keywordstyle=\color{ckey}\rmfamily\bfseries,
xleftmargin=\parindent,
aboveskip=0.2cm,
belowskip=0.2cm,
basewidth=0.48em,
numberbychapter=false,
showstringspaces=false,
moredelim=[is][\color{ccom}\itshape]{/}{/},
escapeinside={(/}{/)},
literate={:: }{{$::$}}2 {=>}{{\Ra}}2 {->}{{\ra}}2
{∀}{{\fa}}1 {==}{{\tteq}}1 {...}{{\scriptsize\bf\dots}}2
{>>>}{{\scriptsize\comp}}3 {>=>}{{\scriptsize\kleisli}}3
{.1}{{$_\mathit{1}$}}1 {.2}{{$_\mathit{2}$}}1
{.n}{{$_\mathit{n}$}}1 {.k}{{$_\mathit{k}$}}1
{.Aux}{{\large$_\mathit{\hspace{0,05cm} Aux}$}}3
{..Aux}{{\large$_\mathit{\hspace{-0,03cm} Aux}$}}3
{@}{{@\hspace{-0,045cm}}}2
{_}{{\underline{\hspace{0.45em}}}}1
{+}{{\scriptsize+}}1
{.-}{{\nhs-}}1
{-.}{{-\nhs}}1
}

\lstdefinestyle{ttstyle}{
basicstyle=\color{ctt}\ttfamily,
xleftmargin=\parindent,
aboveskip=0.2cm,
belowskip=0.2cm,
basewidth=0.5em,
literate={>>>}{{>\nhs>\nhs>}}2 {>=>}{{>\nhs=\nhs>}}2
}

\urlstyle{same}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
%\renewcommand\UrlFont{\color{blue}\rmfamily}

\definecolor{cbasic}{HTML}{5C3566}
\definecolor{cid}{HTML}{002184}
\definecolor{ckey}{HTML}{BE6A0D}
\definecolor{ccom}{HTML}{A0821E}
\definecolor{ctt}{HTML}{223244}

\newcommand{\hs}{\hspace{0.1cm}}
\newcommand{\nhs}{\hspace{-0.06cm}}

\newcommand{\tg}{\textgreater}
\newcommand{\Ra}{$\Rightarrow$}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\fa}{$\forall$}
\newcommand{\tteq}{{\scriptsize$\thicksim$}}
\newcommand{\comp}{\tg\nhs\tg\nhs\tg}
\newcommand{\kleisli}{\tg\nhs=\nhs\tg}
\newcommand{\ann}{:\texttt{\nhs}:}
\newcommand{\ds}{.\nhs.\nhs.}

\newcommand{\K}[1]{\lstinline[style=fancy]{#1}}

\newcommand{\lset}{\lstset{basicstyle=\normalsize\ttfamily}}

\makeatletter
\lst@AddToHook{OnEmptyLine}{\vspace{-0.2255cm}}
\makeatother

\makeatletter
\newenvironment{CenteredBox}{
\begin{Sbox}}{
\end{Sbox}\centerline{\parbox{\wd\@Sbox}{\TheSbox}}}
\makeatother

\begin{document}
%
\title{Handling Recursion in Generic Programming Using Closed Type Families}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Anna Bolotina\inst{1} \and
Artem Pelenitsyn\inst{2}
}
%
%\authorrunning{F. Author and S. Author}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Southern Federal University, Rostov-on-Don, Russia\\
\email{bolotina@sfedu.ru} \and
Czech Technical University in Prague, Prague, Czech Republic\\
\email{pelenart@fit.cvut.cz}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Many of the extensively used libraries for datatype-generic programming offer a fixed-point view on datatypes to express their recursive structure. However, some other approaches, especially the ones based on sums of products, avoid the fixed point encoding. They facilitate implementation of generic functions that do not require to look at the recursive knots in a datatype representation, but raise issues otherwise. A widely used and unwelcome solution to the problem resorts to overlapping instances. In this paper, we present an alternative approach that uses closed type families to eliminate the need of overlap for handling recursion in datatypes. Moreover, we show that this idiom allows for generic programming with families of mutually recursive datatypes.

%The \textsf{generics-sop} library is an approach to representing data using $n$-ary sums and products that both are list-like structures, which is different from the classical view where datatypes are expressed by separate binary sums and products, and it does not encode recursive knots explicitly as with the fixed-point view. We choose this approach as a case study to demonstrate our solution.

\keywords{Datatype-generic programming \and Sums of products \and Recursion \and Overlapping instances \and Closed type families \and Zipper \and Mutually recursive datatypes \and Haskell.}
\end{abstract}
%
%
%
\section{Introduction}
\label{sec:introduction}

A classical way to generically express a datatype is to represent its constructors as the chains of nested \emph{binary} sums, and turn constructor arguments into the chains of nested \emph{binary} products~\cite{VanNoort2008,Cheney2002,Loeh2004}\nocite{Rodriguez2008}\nocite{Magalhaes2012}. De Vries and L\"{o}h~\cite{VriLoeh2014} describe a different sum-of-products approach to representing data using $n$-ary sums and products that are both lists of types; a sum of products is thus a list of lists of types. They call their view SOP which stands for a ``sum of products''. It is implemented in the \textsf{generics-sop}~\cite{generics-sop} library and is based on several relatively recent extensions to the Haskell type system, such as \emph{data kinds}, \emph{kind polymorphism}~\cite{Yorgey2012} and \emph{constraint kinds}.
%, and \emph{GADTs}~\cite{Schrijvers2009}. -- very old extension, 2003 approx.
Using these Haskell features, the library provides the generic view and equips it with a rich collection of high-level combinators, such as ones for constructing sums and products, collapsing to homogeneous structures, and others. They form an expressive instrument for defining generic functions in a more succinct and high-level style as compared to the classical binary sum-of-products views.

There are many generic functions that deal with the recursive knots when traversing the structure of datatypes. Some of the most general examples are \emph{maps}~\cite{Magalhaes2010} and \emph{folds}~\cite{Meijer1991}; more advanced one is a \emph{zipper}~\cite{Huet1997,HiJeLo2004,Adams2010}. For handling recursion, several generic programming approaches express datatypes in the form of polynomial functors closed under fixed points~\cite{MuRec2009,Jansson1997,Loeh2011}. The SOP view naturally supports definitions of functions that do not require a knowledge about recursive occurrences, but otherwise becomes unhandy.

One possible solution to the aforementioned shortcoming of SOP is to modify its core by explicitly encoding recursive positions using the fixed-point approach. However, this may complicate the whole framework significantly. Besides, such a decision may lead to extra conversions between the generic views.

Another known solution uses overlapping instances. This, usually unwelcome, Haskell extension complicates reasoning about the semantics of code. In particular, the program behavior becomes unstable, for it can be affected by any module defining more specific instances. Morris and Jones~\cite{Morris2010} extensively discuss the problems arising from overlapping instances.
% and introduce the type system \textsf{ilab} with a feature called \emph{instance chains} that advances control of overlap. 
The overlap problem also strikes in the security setting when code is compiled as \K{-XSafe} because GHC does not reflect unsafe overlaps and marks the module as safe~\cite{sh-overlapping}.
%Kiselyov et al.~\cite{Kiselyov2004} show how to localize overlap for access operations in a systematic way. Using \textit{closed type families}~\cite{Eisenberg2014}, we introduce an idiom that allows us to completely eliminate overlap for handling recursion.
% -- this should go to Realted Work (if stays in the paper at all)

The problem of using overlapping instances was first addressed by Kiselyov~et~al.~\cite{Kiselyov2004}. Their technique for avoiding overlap relies on a Haskell 98 extension for functional dependencies. The solution proposes two variants of defining a type-level equality predicate, a type class, and then systematically localizes overlap by circumventing it with that predicate. The first version of type equality maps types to unique type representations and compares them. That variant and its later implementation with type families~\cite{Kiselyov2012} fully eliminate \textsf{OverlappingInstances}. Although, each type needs a representation instance to be derived---by means of Template Haskell or GHC. The most generic solution for type equality, the second version, again makes use of overlapping instances, however.

Closed type families, today's Haskell extension, has been proposed primarily to obviate the need for overlapping instances. In the area of generic programming, the extension does not seem to be widely leveraged yet. Exploiting this observation, we make the following contributions.
\begin{itemize}
\item We describe the problem with the current approach of SOP in detail (Section~\ref{sec:sop-problem}).
\item We introduce an idiom that overcomes the problem. The approach avoids both, the use of overlapping instances and changing a generic representation (Section~\ref{sec:handling-recursion}).
% -- 
%\item We provide a convenient interface for generic functions: there is no need to manually declare type class instances for using them.
% -- this doesn't sound like a contribution
\item We evaluate our approach through the development of a larger-scale use case---the generic zipper. The zipper is meant to be easily and flexibly used with families of mutually recursive datatypes (Section~\ref{sec:generic-zipper}).
\item We note, that our approach can contribute to the \textsf{generics-sop}'s one eliminating some boilerplate instance declarations, which necessarily  arise in practice as a consequence of absence of information about recursion points. An example of that, taken from the \textsf{basic-sop}~\cite{basic-sop} package, is discussed in Section~\ref{subsec:gshow}.
\end{itemize}

We believe that the idea presented is suitable for any sum-of-products approach that does not employ the fixed point view and thus subject to the problem. We choose the \textsf{generics-sop} library as a case study because it appears to be a widely applicable library and builds on powerful language extensions implemented in GHC.

\section{The SOP universe and the problem}
\label{sec:sop-problem}

In this section, we first review the SOP view on data, describing its basic concepts to introduce the terminology we are using. Then we discuss the problem with handling recursion by generic functions and illustrate it with a short example.

\subsection{The SOP view}
\label{sec:sop-view}

We first explain the terminology we adopt from SOP~\cite{VriLoeh2014,Loeh2015} and use throughout the paper. The main idea of the SOP view is to use $n$-ary sums and products to represent a datatype as an isomorphic code whose kind is a list of lists of types. The SOP approach expresses the code using the \textsf{DataKinds} extension, with a type family:
\begin{lstlisting}[style=fancy][style=fancy]
type family Code (a :: *) :: [[*]]
\end{lstlisting}
An $n$-ary sum and an $n$-ary product are therefore modelled as type-level heterogeneous lists: the inner list is an $n$-ary product that represents a sequence of constructor arguments, while the outer list, an $n$-ary sum, corresponds to a choice of a particular constructor.

Consider, for instance, a datatype of binary trees:
\begin{lstlisting}[style=fancy]
data Tree a = Leaf a | Node (Tree a) (Tree a)
\end{lstlisting}
This datatype is isomorphic to the following code:
\begin{lstlisting}[style=fancy]
type instance Code (Tree a) = '[ '[a], '[Tree a, Tree a]]
\end{lstlisting}

\begin{figure}[t]
\begin{CenteredBox}
{\lset
\begin{lstlisting}[style=fancy]
data NP (f :: k -> *) (xs :: [k]) where
  Nil  :: NP f '[]
  (:*) :: f x -> NP f xs -> NP f (x ': xs)

data NS (f :: k -> *) (xs :: [k]) where
  Z :: f x -> NS f (x ': xs)
  S :: NS f xs -> NS f (x ': xs)
\end{lstlisting}}
\end{CenteredBox}
\caption{Datatypes for $n$-ary sums and products.}
\label{fig:ns-np}
\end{figure}

%A type of promoted lists has no inhabitants, so the universe provides datatypes to operate on $n$-ary sums and products as on terms.
% -- this sentence falls out of the flow of the paragraph

As shown in Figure~\ref{fig:ns-np}, the datatypes \K{NS} for an $n$-ary sum and \K{NP} for an $n$-ary product are defined as GADTs and are \emph{indexed}~\cite{HiJeLo2004} by a promoted list of types. The encoding also holds an auxiliary type constructor \K{f} (typically, a functor) which is meant to be applied to every element of the index list. Therefore, \K{NP} is a modest abstraction over a heterogeneous list. 

The definitions of \K{NS} and \K{NP} are kind polymorphic. The index list is allowed to contain types of arbitrary kind \K{k}, since \K{k} turns to \K{*} by applying the type constructor \K{f}.
Basic instantiations of type parameter \K{f} found in SOP are identity functor \K{I}, that is, a type-level equivalent for \K{id} function, and a constant functor \K{K}, an analogue of \K{const}:
\begin{lstlisting}[style=fancy]
newtype I (a :: *)          = I {unI :: a}
newtype K (a :: *) (b :: k) = K {unK :: a}
\end{lstlisting}
If instantiated with \K{I}, \K{NP} is a plain heterogeneous list, while \K{K a} turns it into a homogeneous one, isomorphic to \K{[a]}. Here is an example value of type \K{NP I}:
\begin{lstlisting}[style=fancy]
I 5 :* I True :* I 'x' :* Nil :: NP I '[Int, Bool, Char]
\end{lstlisting}

We turn to the sum definition now. The constructor \K{S} of \K{NS}, given an index in $n$-element list, results in an index in a list with $n+1$ elements, skipping the first one, while \K{Z} stores the payload of type \K{f x}. For example, the following chooses the third element of a sum:
\begin{lstlisting}[style=fancy]
S (S (Z (I 5))) :: NS I '[Char, Bool, Int, Bool]
\end{lstlisting}
The sum constructors are similar to Peano numbers, so the choice from a sum of products of a datatype matches the index of its particular constructor in the index list and stores the product representing arguments of that constructor.

With the \K{NS} and \K{NP} machinery at hand, SOP defines the \K{Generic} class with conversion functions \K{from} and \K{to} witnessing the isomorphism between a datatype and its generic representation:
\begin{lstlisting}[style=fancy]
type Rep a = SOP I (Code a)

class All SListI (Code a) => Generic (a :: *) where
  type Code a :: [[*]]
  from :: a -> Rep a
  to   :: Rep a -> a
\end{lstlisting}
The sum of products type, \K{SOP f}, is a newtype-wrapper for \K{NS (NP f)}, and the structural representation \K{Rep} of a datatype \K{a} is a type synonym for a \K{SOP I} of \K{a}'s code. The functions, \K{from} and \K{to}, perform a shallow conversion of the datatype topmost layer---they do not recursively translate the constructor arguments.

We leave out discussion of the \K{SListI} constraint in the \K{Generic} class definition as irrelevant to our work. Although, we do use \K{All} constraint combinator (as in \K{All SListI}) in the following. Therefore, it is worth noting that \K{All} applies a particular constraint (e.g. \K{SListI} above) to each member of a list of types. The usage of constraints as type arguments is allowed due to the \textsf{ConstraintKinds} language extension introducing a dedicated kind \K{Constraint}.

We have introduced generic representation employed by the SOP library and are ready to describe the problem of handling recursion points, stemming from the representation. 

\subsection{Problem with handling recursion}
\label{subsec:recursion-problem}

We illustrate the problem through a short example. The \textsf{QuickCheck} library~\cite{Claessen2011} for automatic testing of Haskell code defines a helper function \K{subterms} that takes a term and obtains a list of all its immediate subterms that are of the same type as the given term, that is, all the recursive positions in the term structure. In the following, we reimplement this function using the SOP view. But first we give a sketch of solution to introduce the idea.

\subsubsection{Non-implementation}

We outline one possible approach to SOP-based implementation of \K{subterms} below. It gives a clear idea of our intention, but so far, we miss the necessary toolbox (in particular, \K{typeOf} / \K{castEq}) to finish it.
\begin{lstlisting}[style=fancy]
subterms :: Generic a => a -> [a]
subterms = subtermsNS . unSOP . from

subtermsNS :: NS (NP I) xss -> [a]
subtermsNS (S ns) = subtermsNS ns
subtermsNS (Z np) = subtermsNP np

subtermsNP :: ∀a xs. NP I xs -> [a]
subtermsNP (I y :* ys)
  | typeOf @a y = castEq y : subtermsNP ys
  | otherwise    = subtermsNP ys
subtermsNP Nil = []
\end{lstlisting}
The function \K{subterms} translates the term to its representation, unwrapping the sum of products from \K{SOP}, and passes that to the auxiliary function \K{subtermsNS}. The latter merely traverses the sum and, once reaches the product,  passes it further to \K{subtermsNP}.

The algorithm of \K{subtermsNP} is straightforward---it traverses the product, appending the current element to the result list if its type is the same as of the original term, otherwise skipping the element. We use GHC's \textsf{TypeAppications} extension to pass that type.

Note that our implementation uses plain pattern matching for reasons of simplicity. However, in Section~\ref{subsec:solve-subterms}, we show a higher-level solution using one of the primary advantages of \textsf{generics-sop}---high-level traversal functions.

\subsubsection{Overlap-based implementation}

Now, we need a way to check type equality and, in the case of equal types, to witness that the element is of the desired type. There is no clear path to this at the moment. Therefore, we step back (until Section~\ref{subsec:solve-subterms}) and, to implement \K{subtermNP}, follow the \textsf{QuickCheck}'s example\footnote{The \textsf{QuickCheck} library applies another approach to generic programming, namely \textsf{GHC.Generics}.}, using overlapping instances of a dedicated class instead.
\begin{lstlisting}[style=fancy]
class Subterms a (xs :: [*]) where
  subtermsNP :: NP I xs -> [a]

instance Subterms a xs => Subterms a (x ': xs) where
  subtermsNP (_   :* xs) = subtermsNP xs
instance /{.-# OVERLAPS #-.}/
         Subterms a xs => Subterms a (a ': xs) where
  subtermsNP (I x :* xs) = x : subtermsNP xs
instance Subterms a '[] where
  subtermsNP _ = []
\end{lstlisting}

To make the whole solution work, we need to propagate the constraints all the way through \K{subtermsNS} and \K{subterms} signatures:
\begin{lstlisting}[style=fancy]
subterms   :: (Generic a, All (Subterms a) (Code a))
           => a -> [a]
subtermsNS :: All (Subterms a) xss
           => NS (NP I) xss -> [a]
\end{lstlisting}

Although the approach works, as exemplified by a number of the packages on Hackage, we aim for release of generic programs from overlap. This would remove the complexity overhead introduced by the approach, as we have mentioned in the introduction.


\section{Handling recursion with closed type families}
\label{sec:handling-recursion}


In the previous section, we have shown a solution to the problem of handling recursion, which uses overlapping instances. We are going to improve the solution and remove overlap now.

Closed type families are the Haskell language extension introduced by Eisenberg et al.~\cite{Eisenberg2014}. The main idea of the extension is that the equations for a \emph{closed type family} are disallowed outside its declaration. Under the extension, we can give the following definition of type-level equality:
\begin{lstlisting}[style=fancy]
type family Equal a x :: Bool where
  Equal a a = 'True
  Equal _ _ = 'False
\end{lstlisting}
The equations in a closed type family are matched in a top-to-bottom order. Since the order is fixed, the overlapping equations here cannot be used to define unsound type-level equations.

\subsection{Solution to \K{subterms} revised}
\label{subsec:solve-subterms}

We now return to our running example from Section~\ref{subsec:recursion-problem}. With the type equality predicate, we can decide if \K{a == b} by defining a type class:
\begin{lstlisting}[style=fancy]
class DecideEq (eq :: Bool) (a :: *) (b :: *) where
  decideEq :: Maybe (b :==: a)

instance a == b => DecideEq True  a b where
  decideEq = Just Refl
instance          DecideEq False a b where
  decideEq = Nothing
\end{lstlisting}
If the types \K{a} and \K{b} are the same, the \K{:==:} type from \K{Data.Type.Equality} witnesses the equality.

For every element in a list of all direct subterms of a term we shall provide a proof object witnessing its type (in)equality to the type of the term. This can be done by means of the \K{All} combinator and partially applied dedicated type class \K{ProofEq}, which abbreviates the heavy-weighted interface of \K{DecideEq}:
\begin{lstlisting}[style=fancy]
class    DecideEq (Equal a b) a b => ProofEq a b
instance DecideEq (Equal a b) a b => ProofEq a b
\end{lstlisting}
The equality proof can then be employed to provide a type-safe cast between two equal types:
\begin{lstlisting}[style=fancy]
castEq :: ∀a b. ProofEq a b => b -> Maybe a
castEq t = (\d -> castWith d t) <$> decideEq @(Equal a b)
\end{lstlisting}

Below we show two variants of completing the \K{subterms} implementation. The low-level version performs pattern matching on the structure of \K{NS} and \K{NP}, as we do in Section~\ref{subsec:recursion-problem}. For this variant, we reimplement \K{subtermsNP}. The different implementation employes powerful machinery of high-level combinators---one of the major advantages provided by \textsf{generics-sop}. Although, those high-level functions become one extra layer of complexity.

\subsubsection{Low-level implementation}

The low-level definition of \K{subtermsNP} using the type cast resembles its outline given in the previous section:
\begin{lstlisting}[style=fancy]
subtermsNP :: ∀a xs. All (ProofEq a) xs => NP I xs -> [a]
subtermsNP (I (y :: x) :* ys) =
  case castEq y of
    Just t  -> t : subtermsNP ys
    Nothing -> subtermsNP  ys
subtermsNP Nil = []
\end{lstlisting}

As a side note, we make use of the \textsf{ScopedTypeVariables} extension in the definition above, as the type of the element being matched does not appear in the function signature, since it may match an empty list. 

To finish up, the \K{ProofEq} constraint must be added to the \K{subterms} and \K{subtermsNS} declarations as well.

\subsubsection{High-level implementation}

By taking advantage of \textsf{generics-sop}'s powerful functions for collapsing and mapping, one can define the functions \K{subtermsNS} and \K{subtermsNP} as follows:
\begin{lstlisting}[style=fancy]
subtermsNS :: ∀a xss. All (AllProofEq a) xss
           => NS (NP I) xss -> [a]
subtermsNS = collapse_NS
           . cmap_NS (Proxy @(AllProofEq a)) subtermsNP

subtermsNP :: ∀a xs. AllProofEq a xs => NP I xs -> K [a] xs
subtermsNP = K . catMaybes
               . collapse_NP
               . cmap_NP (Proxy @(ProofEq a)) (mapIK $ castEq)
\end{lstlisting}
This implementation requires also defining \K{AllProofEq} and properly changing the \K{subterms} type annotation.

In summary, we claim that any generic function accessing recursive knots in the underlying datatype structure can be defined in the way described above for the task of \K{subterms}. We give another example showing how to adapt our idiom to different scenarios in the following subsection.

\subsection{Generic show}
\label{subsec:gshow}

The function \K{show} is a common example of useful functions that traverse a datatype's recursive structure. It is known that this function can be defined in a generic way for an arbitrary datatype. De Vries and L\"{o}h define generic function \K{gshow} in the \textsf{basic-sop} package~\cite{basic-sop} based on the SOP view. We follow their implementation of \K{gshow} for the most part, but improve it in respect of handling recursion. The example shows, how the better implementation, consulting with recursive positions, affects the usability of the function, obviating boilerplate code.

The following exploits the idea of \emph{pattern matching}. As before, we consider two cases. In the first case, when the position we are matching on is not recursive, we only require it to be an  instance of \K{Show}, and invoke its \K{show} function. Whereas in the case of the recursive position, we surround it with parentheses and apply our generic function \K{gshow}. Thus, by means of the type family for equality, we model a form of pattern matching on the types again:
\begin{lstlisting}[style=fancy]
class CaseShow (eq :: Bool) (a :: *) (b :: *) where
  caseShow' :: b -> String

instance Show  b => CaseShow 'False a b where
  caseShow' = show
instance GShow a => CaseShow 'True  a a where
  caseShow' = gshow
\end{lstlisting}
We provide a synonym for the \K{CaseShow (Equal a b) a b} instance, which we call \K{CaseRecShow}, as before with \K{ProofEq}; likewise a synonym for the matching function:
\begin{lstlisting}[style=fancy]
caseShow :: ∀a b. CaseRecShow a b => b -> String
caseShow = caseShow' @(Equal a b) @a
\end{lstlisting}

The resulting function \K{gshow} is a subject of a number of constraints abbreviated by a \K{GShow} synonym:
\begin{lstlisting}[style=fancy]
type GShow a = (Generic a, HasDatatypeInfo a,
                All2 (CaseRecShow a) (Code a))

gshow :: ∀a. GShow a => a -> String
\end{lstlisting}
The function \K{gshow} employs meta-information provided by \textsf{generics-sop}'s class \K{HasDatatypeInfo} to show the names of a datatype constructor and its record fields. The \textsf{generics-sop} library is able to derive this metadata automatically.
The function is also constrained by \K{CaseRecShow} with the \K{All2} combinator that is an analogue of \K{All} for a list of lists of types. 

We define \K{gshow} mutually recursive with \K{caseShow}. The full implemenentation of the function \K{gshow} is left for the extended version of the paper in Technical Report\footnote{\url{https://users.fit.cvut.cz/~pelenart/2018-generic-zipper-tr.pdf}}.

The function \K{gshow} can now be used to generically show data---for example, a value of type \K{Tree Bool}; note that \K{Tree a} from Section~\ref{sec:sop-view} is now assumed to be an instance of \K{Generic} and \K{HasDatatypeInfo}.
\begin{lstlisting}[style=ttstyle]
*Main> let tree = Node (Leaf True) (Leaf False)
*Main> gshow tree

"Node (Leaf True) (Leaf False)"
\end{lstlisting}
Here is a benefit of our implementation: it can be used directly, without any additional instance declarations, whereas \textsf{basic-sop}~\cite{basic-sop} offers the following usage pattern for \K{gshow} and some datatype \K{T}:
\begin{lstlisting}[style=fancy]
instance Show T where
  show = gshow
\end{lstlisting}
This is a consequence of \K{gshow} from \textsf{basic-sop} not treating recursive positions separately, and therefore requiring the \K{Show} constraint for all knots in the datatype structure.


\subsection{Abstract description of the design pattern}
\label{subsec:abstract-pattern}


We can continue along the lines of the previous examples to consider the approach separately from concrete ones. One can use the technique, following the abstracted pattern below:

\begin{lstlisting}[style=fancy]
class DispatchRec.Aux (p :: Bool)
                     (a.1 :: k.1) ... (a.n :: k.n) (b :: *) where
  dispatchRec.Aux :: X b

instance C.1 ... => DispatchRec.Aux 'False a.1 ... a.n b where
  dispatchRec.Aux = f.1
instance C.2 ... => DispatchRec.Aux 'True  a.1 ... a.n b where
  dispatchRec.Aux = f.2

class    DispatchRec.Aux (P a.1 ... a.k b) a.1 ... a.k ... a.n b
  => DispatchRec a.1 ... a.n b
instance DispatchRec.Aux (P a.1 ... a.k b) a.1 ... a.k ... a.n b
  => DispatchRec a.1 ... a.n b

dispatchRec :: ∀a.1 ... a.n b. DispatchRec a.1 ... a.n b => X b
dispatchRec = dispatchRec.Aux @(P a.1 ... a.k b) @a.1 ... @a.k ... @a.n
\end{lstlisting}

This machinery employes the abstract multi-place predicate \K{P} on types, supposed to be a closed typed family, to resolve the overlap of two dispatch branches, as captured by \K{DispatchRec..Aux}. The predicate \K{P} generalizes \K{Equal} to an arbitrary relation on types, so that one can model, e.g., subtyping for some domain-specific language. The introduction of the associated type class \K{DispatchRec} provides a handy interface for dispatch. The dispatch function \K{dispatchRec} decides on one of the functions \K{f.1} and \K{f.2}---depending on whether the predicate \K{P} is true for types \K{a.1}, \dots, \K{a.k}, \K{b}.

For consumer functions, such as \K{subterms} and \K{gshow}, the type \K{X b} typically is instantiated with \K{b -> T} for some datatype \K{T}. The pattern fits equally well for defining producers, such as \K{garbitrary} from the \textsf{basic-sop} package, where \K{X b} would be instantiated with \K{Gen b}.


\section{The generic zipper}
\label{sec:generic-zipper}


The zipper is a data structure that enables efficient navigation and editing within the tree-like structure of a datatype. It represents a current location in that structure, storing a tree node, a \emph{focus}, along with its context. Having a zipper focused on a recursive knot in a structure, we may produce a new location by moving the focus up, down, left, or right. On the way, we can update the nodes. Entering and leaving the navigation usually need a special care.

The classical zipper described by Huet~\cite{Huet1997} can be generically calculated for regular datatypes~\cite{HiJeLo2004}---all datatypes expressible as polynomial expressions on types. Yakushev~et~al.~\cite{MuRec2009} generalize the definition of the generic zipper for an arbitrary family of mutually recursive datatypes. All mentioned solutions require a datatype to be expressed using forms of a fixed-point operator, since the zipper operates on recursion points. 

In this section, we describe our approach allowing one to define the generic zipper out of a representation that does not exploit a fixed point. We start with the generic zipper interface and an example of how it can be used (Section~\ref{ss:zip-interface}). Then, we turn to the type-level machinery employed to define locations inside mutually recursive datatypes using the SOP view  (Section~\ref{ss:locs}).

In Technical Report, we discuss the implementation of the generic zipper interface---the functions for manipulating locations. The source code with the full implementation of the zipper is available at our \textsf{GitHub} repository\footnote{\url{https://github.com/Maryann13/Zipper}}.

\subsection{Interface and usage}
\label{ss:zip-interface}

The interface we provide for the generic zipper is shown on Figure~\ref{fig:zipper-interface}. It comprises the functions for \emph{movement}, \emph{starting} and \emph{ending navigation}, and \emph{updating} the focus, which are defined over the location structure.
\begin{figure}[t]
\begin{CenteredBox}
{\lset
\begin{lstlisting}[style=fancy]
(/\textbf{\textrm{\color{black}Movement functions}}/)

goUp    :: Loc a fam c -> Maybe (Loc a fam c)
goDown  :: Loc a fam c -> Maybe (Loc a fam c)
goLeft  :: Loc a fam c -> Maybe (Loc a fam c)
goRight :: Loc a fam c -> Maybe (Loc a fam c)

(/\vspace{-0.3cm}/)
(/\textbf{\textrm{\color{black}Starting navigation}}/)

enter   :: ∀fam c a. (Generic a, In a fam, Zipper a fam c)
        => a -> Loc a fam c

(/\vspace{-0.3cm}/)
(/\textbf{\textrm{\color{black}Ending navigation}}/)

leave   :: Loc a fam c -> a

(/\vspace{-0.3cm}/)
(/\textbf{\textrm{\color{black}Updating}}/)

update  :: (∀b. c b => b -> b) -> Loc a fam c -> Loc a fam c
\end{lstlisting}}
\end{CenteredBox}
\caption{Generic zipper interface.}
\label{fig:zipper-interface}
\end{figure}

The functions \K{goUp}, \K{goDown}, \K{goLeft}, and \K{goRight} produce a location with the focus moved \emph{up} to the parent of the focal subtree, \emph{down} to its leftmost child, \emph{left} and \emph{right} to the left and right sibling, respectively, if it is possible. A movement may fail, as specified by the \K{Maybe} monad, if we cannot go further in a chosen direction. Navigation in a tree starts at the root, and the type variable \K{a} refers to the root type that remains the same during the navigation, while the type in the focus of the location may vary and is one of the types in a type list \K{fam}.

The function signature of \K{enter} specifies the constraints necessary to begin navigation in a structure. Firstly, a datatype of the structure needs to have the \K{Generic} representation. Secondly, the \K{In} constraint checks if type \K{a} is a member of a type family \K{fam}. Thirdly, the \K{Zipper} constraint collects specific constraints that refer to the implementation of movement operations. Note that the universal quantifier here sets the instantiation order of the type variables for type applications that will be a part of our usage pattern for the zipper. 

The \K{leave} function ends navigation moving up to the root and returns its modified value. 

The \K{update} function modifies the focal subtree with a given constrained function. The type in focus is existentially quantified inside \K{Loc} and should satisfy the constraint \K{c}. The structure of \K{Loc} (shown in Section~\ref{ss:locs}) guarantees that the constraint holds for all types in the family \K{fam} and, therefore, for all recursive nodes that can be in focus, hence \K{update} can always be applied.

Consider the following example of usage of the interface. Define a pair of mutually recursive datatypes for a rose tree and a forest, where the forest is a list of trees, and the tree is defined as a value in a node and a forest of its children:
\begin{lstlisting}[style=fancy]
data RoseTree a = RTree a (Forest a)

data Forest   a = Empty | Forest (RoseTree a) (Forest a)
\end{lstlisting}

Updating the trees can be done through a class:
\begin{lstlisting}[style=fancy]
class UpdateTree a b where
  replaceBy :: RoseTree a -> b -> b
  replaceBy _   = id
instance UpdateTree a (RoseTree a) where
  replaceBy t _ = t
instance UpdateTree a (Forest a)
\end{lstlisting}
This replaces a tree node with a given tree, and, for the forests, this leaves the nodes untouched.

For chaining moves and edits, we can follow Yakushev~et~al.~\cite{MuRec2009} and employ  the flipped function composition \K{>>>}~and Kleisli composition \K{>=>}. The latter is instantiated with the \K{Maybe} monad that wraps the result type of the movement functions.
\begin{lstlisting}[style=fancy]
(>>>) :: (a -> b) -> (b -> c) -> (a -> c)
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
\end{lstlisting}

The type family we need to run the example is defined as follows:
\begin{lstlisting}[style=fancy]
type TreeFam a = '[RoseTree a, Forest a]
\end{lstlisting}

Finally, we can use zipper operations with our updating function to traverse and replace a part of a forest:
\begin{lstlisting}[style=ttstyle]
*Main> let forest
         = Forest (RTree 'a' $ Forest (RTree 'b' Empty) Empty)
                  (Forest (RTree 'x' Empty) Empty)

*Main> let t = RoseTree 'c' Empty

*Main> enter @(TreeFam Char) @(UpdateTree Char)
         >>> goDown >=> goRight >=> goDown
         >=> update (replaceBy t)
         >>> leave >>> return $ forest
\end{lstlisting}
This yields the following result:
\begin{lstlisting}[style=fancy]
Forest (RTree 'a' $ Forest (RTree 'b' Empty) Empty)
       (Forest (RTree 'c' Empty) Empty)
\end{lstlisting}

Our zipper applies to regular datatypes as well. In that case, \K{fam} list shall contain a single element. Generally, the interface is flexible enough to allow us to check in any collection of types we are interested in during traversal. However, we demand an updating operation to rely on a type class function to distinguish the types of the nodes.

\subsection{Locations}
\label{ss:locs}

The location structure consists of a focal subtree, which is one of the mutually recursive nodes of the whole structure of the family of datatypes, and its surrounding context:
\begin{lstlisting}[style=fancy]
data Loc (r :: *) (fam :: [*]) (c :: * -> Constraint) where
  Loc :: Focus r a fam c -> Contexts r a fam c
      -> Loc r fam c
\end{lstlisting}
The type parameters \K{r}, \K{fam}, and \K{c} in \K{Loc} correspond to the root type of the tree, the list of types of nodes to visit, and a constraint imposing restrictions on the types in the list, respectively. Also, the single constructor is existentially quantified over one more type variable, \K{a}, for we need to store a type of the focus' parent to be able to move up successively in a tree-like structure. We discuss both the term parameters of the constructor of \K{Loc} in detail below. 

\subsubsection{Focus}

The subtree in focus is wrapped by the \K{Focus} datatype. 
The wrapper incapsulates the proofs about a number of important properties of a focus.
\begin{lstlisting}[style=fancy]
data Focus (r :: *) (a :: *) (fam :: [*])
           (c :: * -> Constraint) where
 Focus :: (Generic b, In b fam, ZipperI r a b fam c)
       => b -> Focus r a fam c
\end{lstlisting}
Existential type variable \K{b} represents the type of a focus. We apply a number of predicates to \K{b}, hence we can implement the steps of the navigation not knowing the actual type of a focus. Firstly, the type of a focus should have the \K{Generic} representation. Secondly, it should live \K{In} the list of types we are going to visit. Lastly, it ought to satisfy the set of constraints for the whole zipper interface captured by the \K{ZipperI} predicate. In particular, the predicate ensures that \K{a} is the type of the parent for the focus in the structure under consideration. Also, it guarantees that \K{b} fulfils the constraint \K{c}. Again, we make \K{c} embedded in \K{Loc} by reason of existentiality of \K{b}, which precludes the enforcement of this restriction by means of external \K{All}.

We implement the \K{In} constraint by means of a type family \K{InFam} exactly along the lines of the \K{Equal} type family defined in the beginning of Section~\ref{sec:handling-recursion}. 
%~ The following checks a type for membership of a type-level list that we use to express a family:
%~ \K{
%~ \vs
%~ \indent type family InFam (a :: k) (fam :: [k]) :: Bool where\\
%~ \indent\s\s InFam a (a ': fam) = 'True\\
%~ \indent\s\s InFam a (x ': fam) = InFam a fam\\
%~ \indent\s\s InFam a '[]\ind\ind = 'False
%~ \vs
%~ }
%~ The \K{In} constraint is defined as
\begin{lstlisting}[style=fancy]
type In a fam = InFam a fam == 'True
\end{lstlisting}
The definition of \K{InFam} is omitted as a boring one.

One last missing piece for managing focuses is the class \K{ProofFocus}. It provides a proof of membership of a focus type to a family. Again, this generalizes (in a weak form) the proof of type equality from Section~\ref{subsec:solve-subterms}. The definitions of \K{ProofFocus} and an auxiliary class \K{ProofFocus..Aux} are given in Figure~\ref{fig:proof-in}. In the setting of families, where there are no analogues of \K{:==:}, we can define only a weak kind of proof, which is more flexible. We can then make it handy by defining a function \K{castFocus} using \K{castFocus..Aux}, as with \K{castEq} before.
%The constraints on the second \K{ProofFam} instance, which repeat the same ones from the \K{Family} constructor, constitute the proof.
% this is not clear and, I think, can be omitted

\begin{figure}[t]
\begin{CenteredBox}
{\lset
\begin{lstlisting}[style=fancy]
class ProofFocus.Aux (inFam :: Bool) (r :: *) (a :: *) (b :: *)
                    (fam :: [*]) (c :: * -> Constraint) where
  castFocus.Aux :: b -> Maybe (Focus r a fam c)

instance ProofFocus.Aux 'False r a b fam c where
  castFocus.Aux _ = Nothing
instance (Generic b, In b fam, ZipperI r a b fam c)
      => ProofFocus.Aux 'True  r a b fam c where
  castFocus.Aux   = Just . Focus

class    ProofFocus.Aux (InFam b fam) r a b fam c
    => ProofFocus r a b fam c
instance ProofFocus.Aux (InFam b fam) r a b fam c
    => ProofFocus r a b fam c
\end{lstlisting}}
\end{CenteredBox}
\caption{Proof of membership of a family of datatypes.}
\label{fig:proof-in}
\end{figure}

\subsubsection{Contexts}

A focus on a particular node, augmented with a surrounding context of that node, is enough to reconstruct the entire structure. Therefore, the context of a location has the shape of the original structure but with one hole at the place of its focus. This is sometimes called a \emph{one-hole context}. 

The context can be expressed as a stack, called \K{Contexts}, and each frame, \K{Context}, corresponds to the particular node with a hole. The stack ascends from the focal node keeping its siblings, the siblings of its parent, etc., until it reaches the root node. So the stack of contexts, essentially, reflects the track of the movement inside the structure.
\begin{lstlisting}[style=fancy]
data Contexts (r :: *) (a :: *) (fam :: [*])
              (c :: * -> Constraint) where
 CNil :: Contexts a a fam c
 Ctxs :: (Generic a, In a fam, ZipperI r x a fam c)
      => Context fam a -> Contexts r x fam c
      -> Contexts r a fam c
\end{lstlisting}
The type parameters have the same meaning as for the \K{Loc} datatype. The \K{ZipperI} constraint with the type \K{x} of the previous context frame indicates that the constraint for the zipper holds after plugging the focus in the hole. Therefore, all the properties can be proved by induction for the focus type when it moves down in the tree adding new contexts onto the stack. The \K{CNil} constructor for an empty context, with the \K{r} and \K{a} types being equal, forms the inductive basis in that kind of proof. 

Note that the type of the current focus is not reflected in the \K{Contexts} datatype.

\subsubsection{Type-Level Differentiation}

McBride~\cite{McBride2001} studies a relation between the one-hole context definition and \emph{partial differentiation} from calculus: he shows that the type of the context for an arbitrary (regular) type can be derived mechanically from that type by means of a list of differentiation \emph{rules} that serve as formulaic instructions for computing the type in type-level programming. Yakushev~et~al.~\cite{MuRec2009} then demonstrate that the method can be generalized for mutually recursive datatypes. We adapt that technique to \textsf{generics-sop}, and now need a few auxiliary type-level functions to implement the computation of the context type. Those functions, defined recursively via type families, provide algebraic operations for lists of types (which we regard as sums and products of types): addition and multiplication. Specifically, we introduce addition \K{.++} of two sums of products (SOP) of types, multiplication \K{.*} of a SOP by a single type, and multiplication \K{.**} of a SOP by a product of types. The definition of the latter uses \K{.*}.

The addition operation just appends two type-level lists of lists (sums of products), multiplication by a type adds the type to the head of each inner list of the sum (here we see multiplication of a product and the distributive property of multiplication over addition, just as in arithmetic of numbers), and multiplication by a product appends the list to the head of each inner product of the sum. We define multiplication by a type below. The definitions for the other type-level operations are similar.
\begin{lstlisting}[style=fancy]
type family (.*) (x :: *) (ys :: [[*]]) :: [[*]] where
  x .* (ys ': yss) = (x ': ys) ': (x .* yss)
  _ .* '[]         = '[]
\end{lstlisting}

Again, kind \K{[*]} denotes products, and \K{[[*]]} denotes sums (of products), so the relation with arithmetic of numbers becomes more clear if one realizes that an empty sum \K{'[] :: [[*]]} corresponds to $0$, and an empty product \K{'[] :: [*]} corresponds to $1$.

\subsubsection{Context Frame}

At this point, we can implement differentiation of a product of types and, therefore, the computation of a context frame type\footnote{The actual definitions slightly differ from ones, presented in the following. We omit some implementation details for simplicity.}. 

The definition of differentiation resembles its analogue from calculus, but it is now generalized for the setting of families of datatypes:
\begin{lstlisting}[style=fancy]
type family DiffProd (fam :: [*]) (xs :: [*]) :: [[*]] where
  DiffProd _   '[]       = '[]
  DiffProd fam '[x]      = If (InFam x fam) '[ '[]] '[]
  DiffProd fam (x ': xs) =
    xs .** DiffProd fam '[x] .++ '[x] .** DiffProd fam xs
\end{lstlisting}
The differentiation of the single type reflected by a one-element list here results in $0$ reflected by \K{'[]}, if that is not in the family and hence is regarded as a constant. Otherwise it results in $1$ represented by the sum \K{'[ '[]]}. When differentiation gives $1$, it is actually the hole. We also use type-level \K{If} that returns its second argument for \K{'True}, and the third one otherwise. We do not give its definition here, as it is straightforward.

The following completes the computation of the context type:
\begin{lstlisting}[style=fancy]
type family ToContext (fam :: [*])
                      (code :: [[*]]) :: [[*]] where
  ToContext _   '[]         = '[]
  ToContext fam (xs ': xss) =
    DiffProd fam xs .++ ToContext fam xss
\end{lstlisting}
The type family \K{ToContext} derives the type of the context of a datatype performing differentiation of a sum on its code.

Finally, the type of a context frame representation is a type synonym:
\begin{lstlisting}[style=fancy]
type Context fam a = SOP I (ToContext fam (Code a))
\end{lstlisting}


\section{Discussion}
\label{sec:discussion}

In this section, we give a discussion of some concerns relating to the scope and user-friendliness of the introduced no-overlap technique for handling recursion.

\subsubsection{Polymorphic recursion}

The approach, described in this paper, is applicable to a range of datatypes that are \emph{monomorphically recursive}. Any of those datatypes has the same type parameters in the left-hand side of its definition and at its recursion points (e.g. \K{Tree a} from Section~\ref{sec:sop-view}). We can go further and proceed with a solution for generic functions, which covers some datatypes whose type parameters in each recursive knot may differ from those in its parent. It turns out, as we will show below, that the solution allows for datatypes with a ``simple'' form of \emph{polymorphic recursion}, but fails to work for \emph{nested datatypes}~\cite{Bird1998}.

Assume we have a polymorphically recursive datatype \K{PolyRec a} defined in terms of a type family \K{Poly}:
\begin{lstlisting}[style=fancy]
data PolyRec a = Tail a | Rec a (PolyRec (Poly a))

type family Poly a where
  Poly Bool = Char
  Poly Char = Bool
  Poly a    = a
\end{lstlisting}

For managing polymorphic recursion in this datatype, we can write an analogue of the \K{Equal} type family from Section~\ref{sec:handling-recursion}, which ignores type parameters when checking two polymorphic types. Since any datatype with type parameters \K{f a b c ...} has kind \K{* -> (* -> (* -> ...))}, a \K{PolyEq} type family can be defined thus:
\begin{lstlisting}[style=fancy]
type family PolyEq (a :: k) (x :: k) :: Bool where
  PolyEq (f a) (g b) = PolyEq f g
  PolyEq a     a     = 'True
  PolyEq _     _     = 'False
\end{lstlisting}

The function \K{gshow} from Section~\ref{subsec:gshow} can be reimplemented by using this type family instead of \K{Equal}. The only piece of its definition must be changed as well in order to recursively invoke the function each time with a new type (with the proper change in the \K{CaseRecShow} definition):
\begin{lstlisting}[style=fancy]
instance Show  a => CaseShow 'False a where
  caseShow' = show
instance GShow a => CaseShow 'True  a where
  caseShow' = gshow
\end{lstlisting}

Unfortunately, this approach, albeit working well for datatypes defined like \K{PolyRec a}, becomes unsuitable for nested datatypes, such as one below:
\begin{lstlisting}[style=fancy]
data Nested a = Epsilon | Nest a (Nested [a])
\end{lstlisting}
The culprit is the constraint \K{All2 (CaseRecShow a) (Code a)} that now turns out to be a root of nonterminating computation of the \K{GShow} constraint for \K{[a]}, \K{[[a]]}, and so on ad infinitum.

Still, one can think of problems where a generic operation uses the recursive structure of data, but has no recursive calls---and, therefore, can tolerate nested datatypes. An example of this kind of problems is \emph{generic generic programming}~\cite{MagLoeh2014}, a technique of defining translations between different generic programming universes. In our setting, it is possible to define a translation from \textsf{generics-sop} to another library with an explicit encoding of recursive positions, such as \textsf{regular}~\cite{VanNoort2008}. This usually needs only to detect recursion points, because the most of generic views provide shallow conversion functions.

\subsubsection{Usability and error-reporting}

The shown no-overlap technique may involve a lot of multiple constraints on generic functions. We tend to abbreviate them with type aliases. Although convenient when reading and writing code, one may encounter a leak in abstraction by making a mistake in client code. In this case, GHC sometimes produces an embarrassingly long error message where multiple underlying constraints are displayed. We currently investigate the \K{TypeError} recent mechanism of GHC which allows for user-defined error messages, specifically targeted for type level-heavy computations.

\section{Related work}
\label{sec:related-work}

There are many works that contribute to the datatype-generic programming. Rodriguez et al.~\cite{Rodriguez2008} and Magalh{\~{a}}es and L{\"{o}}h~\cite{MagLoeh2012} review a number of existing approaches and provide their detailed comparison in various aspects. There are several generic views that use certain forms of the fixed point operator to express recursion in a datatype structure~\cite{VanNoort2008,MuRec2009,Jansson1997,Loeh2011}. And there are a number of approaches that do not make use of fixed points~\cite{Chakravarty2009,Cheney2002,Magalhaes2010,Weirich2006}, but explicitly encode recursion in the datatype representation. The SOP view~\cite{VriLoeh2014}, which we use to demonstrate our technique, is an approach to generic programming that does not reflect recursive positions in the generic representation of a datatype. This approach uses heterogeneous lists of types to encode sums and products in the generic representation.

The idea similar to SOP has been proposed by Kiselyov~et~al.~\cite{Kiselyov2004} in their \textsf{HList} library for strongly typed heterogeneous collections. In the paper, the authors also discuss problems connected with overlap, which they use for access operations. Another Haskell extension, functional dependencies, is applied to restrict overlap by introducing a class for type equality there, which resembles our solution.

Morris and Jones~\cite{Morris2010} introduce the type-class system \textsf{ilab}, based on the Haskell 98 class system, with a new feature called ``instance chains''. This enables one to control overlap by using an explicit syntax in instance declarations. The approach resembles if-else chains. But the use of instance chains and local use of overlap leave code error-prone as a consequence of type class openness. Closed type families~\cite{Eisenberg2014} were recently introduced in Haskell to solve the overlap problem.

Several works show how to define the Zipper~\cite{Huet1997} generically for regular~\cite{HiJeLo2004,McBride2001} and mutually recursive~\cite{MuRec2009} types using fixed-point generic views. Adams~\cite{Adams2010} defines a generic zipper for heterogeneous types: a different kind of zipper that can traverse knots of various types, so it does not use the recursive structure.



\section{Conclusion}
\label{sec:conclusion}

Defining generic functions, which consider recursion points, is easy within generic views that are explicit about recursion in the datatype representation. Not so much otherwise. Although, there are some approaches that address the problem by means of global or local overlaps. We have developed the technique that allows one to define generic functions that treat recursion without its explicit encoding and without overlap. 

We have demonstrated that the method suits for advanced recursive schemes, such as the generic zipper interface. Also, it supports families of mutually recursive datatypes.

Arguably, it is still easier to treat recursion when ``explicit'' encoding is used. On the other hand, we believe, once the problem of handling recursion is shown to be manageable, new generic universes shall emerge, not worrying about the recursion support, but rather focusing on other generic programming problems.

\section*{Acknowledgments}
\label{sec:acks}

We are thankful to Andres L\"{o}h for his helpful recommendations and comments on the paper. We address some insightful questions and suggestions from participants of the TFP symposium, to whom we are deeply grateful. We thank Julia Belyakova, who helped to proof-read certain parts of the paper, 
and the participants of the Seminar on Programming Languages and Compilers at 
I.I.~Vorovich Institute of Mathematics, Mechanics, and Computer Science (Southern Federal
University, Russia), where we presented partial results of the work and got valuable feedback.

This project has received funding from the European Research Council (ERC) under the
European Union's Horizon 2020 research and innovation programme (grant agreement No 695412).

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{lncs-biblio}
%
\end{document}
